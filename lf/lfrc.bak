# Basic Settings
set hidden true
set ignorecase true
set icons true
set drawbox true

# UI Settings
set number true
set relativenumber true
set info size:time
set scrolloff 5
set tabstop 4
set ratios 1:2:3

# ctpv preview settings
set previewer ctpv
set cleaner ctpvclear
&ctpv -s $id
&ctpvquit $id

# Custom commands
cmd open ${{
    case $(file --mime-type -Lb $f) in
        text/*|application/json|inode/x-empty|application/x-subrip) 
            $EDITOR $fx
            ;;
        image/*)
            sxiv $f &
            ;;
        video/*|image/gif)
            mpv --quiet $f &
            ;;
        audio/*)
            mpv --no-video $f &
            ;;
        application/pdf)
            zathura $f &
            ;;
        application/zip|application/x-tar|application/x-rar)
            atool -l $f | less
            ;;
        *)
            xdg-open $f &
            ;;
    esac
}}

cmd mkdir ${{
    printf '%s' "Directory Name: "
    read ans
    mkdir -p "$ans"
}}

cmd mkfile ${{
    printf '%s' "File Name: "
    read ans
    touch "$ans"
}}

cmd chmod ${{
    printf '%s' "Mode Bits: "
    read ans
    chmod $ans $fx
}}

cmd trash ${{
    files=$(printf '%s' "$fx" | tr '\n' ';')
    while [ "$files" ]; do
        file=${files%%;*}
        if [ -e "$file" ]; then
            gio trash "$file"
        fi
        if [ "$files" = "$file" ]; then
            files=''
        else
            files="${files#*;}"
        fi
    done
}}

cmd delete ${{
    set -f
    printf '%s\n' "$fx"
    printf "delete?[y/n]"
    read ans
    [ "$ans" = "y" ] && rm -rf $fx
}}

cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
        *) echo "Unsupported format";;
    esac
}}

cmd compress ${{
    set -f
    printf '%s' "Archive name (without extension): "
    read name
    printf '%s' "Format [zip/tar.gz/tar.xz]: "
    read format
    case $format in
        zip) zip -r "${name}.zip" $fx;;
        tar.gz) tar czf "${name}.tar.gz" $fx;;
        tar.xz) tar cJf "${name}.tar.xz" $fx;;
        *) echo "Unsupported format";;
    esac
}}

cmd fzf_jump ${{
    res="$(find . -maxdepth 3 | fzf --reverse --header='Jump to location')"
    if [ -f "$res" ]; then
        cmd="select"
    elif [ -d "$res" ]; then
        cmd="cd"
    fi
    lf -remote "send $id $cmd \"$res\""
}}


cmd open ${{
    case "$(file --mime-type -Lb -- "$f")" in
        text/*|application/json|inode/x-empty|application/x-subrip)
            ${EDITOR:-nvim} "$fx"
            ;;
        image/*)
            # show image in kitty (inline, no placement numeric args)
            if command -v kitty >/dev/null 2>&1 && [ -n "$KITTY_WINDOW_ID" ]; then
                # clear previous icat images, then stream the image inline
                kitty +kitten icat --silent --clear --transfer-mode=stream "$f" >/dev/null 2>&1 &
            else
                # fallback: use sxiv or xdg-open
                if command -v sxiv >/dev/null 2>&1; then
                    sxiv "$f" &
                else
                    xdg-open "$f" &
                fi
            fi
            ;;
        video/*|image/gif)
            mpv --quiet "$f" &
            ;;
        audio/*)
            mpv --no-video "$f" &
            ;;
        application/pdf)
            zathura "$f" &
            ;;
        application/zip|application/x-tar|application/x-rar)
            atool -l "$f" | less
            ;;
        *)
            xdg-open "$f" &
            ;;
    esac
}}

# Fixed bulk-rename implementation (complete)
cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    ${EDITOR:-nvim} "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && { rm "$old" "$new"; exit; }
    paste "$old" "$new" | while IFS=$'\t' read -r src dst; do
        [ "$src" = "$dst" ] || [ -e "$dst" ] || mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}
cmd mkdir ${{
    printf '%s' "Directory Name: "
    read ans
    mkdir -p "$ans"
}}

cmd mkfile ${{
    printf '%s' "File Name: "
    read ans
    touch "$ans"
}}

cmd chmod ${{
    printf '%s' "Mode Bits: "
    read ans
    chmod $ans $fx
}}

cmd trash ${{
    files=$(printf '%s' "$fx" | tr '\n' ';')
    while [ "$files" ]; do
        file=${files%%;*}
        if [ -e "$file" ]; then
            gio trash "$file"
        fi
        if [ "$files" = "$file" ]; then
            files=''
        else
            files="${files#*;}"
        fi
    done
}}

cmd delete ${{
    set -f
    printf '%s\n' "$fx"
    printf "delete?[y/n]"
    read ans
    [ "$ans" = "y" ] && rm -rf $fx
}}

cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
        *) echo "Unsupported format";;
    esac
}}

cmd compress ${{
    set -f
    printf '%s' "Archive name (without extension): "
    read name
    printf '%s' "Format [zip/tar.gz/tar.xz]: "
    read format
    case $format in
        zip) zip -r "${name}.zip" $fx;;
        tar.gz) tar czf "${name}.tar.gz" $fx;;
        tar.xz) tar cJf "${name}.tar.xz" $fx;;
        *) echo "Unsupported format";;
    esac
}}

cmd fzf_jump ${{
    res="$(find . -maxdepth 3 | fzf --reverse --header='Jump to location')"
    if [ -f "$res" ]; then
        cmd="select"
    elif [ -d "$res" ]; then
        cmd="cd"
    fi
    lf -remote "send $id $cmd \"$res\""
}}

cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS=$'\t' read -r src dst; do
        [ "$src" = "$dst" ] || [ -e "$dst" ] || mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

cmd dragon ${{
    dragon-drop -a -x $fx
}}

cmd yank-path ${{
    printf '%s' "$fx" | wl-copy
    lf -remote "send $id echo Copied path to clipboard"
}}

cmd yank-name ${{
    basename -a -- $fx | head -c-1 | wl-copy
    lf -remote "send $id echo Copied name to clipboard"
}}

cmd paste-overwrite &{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        cp -rf $list .
    elif [ $mode = 'move' ]; then
        mv -f $list .
    fi
    lf -remote 'send clear'
}}

# Key Bindings
map <enter> open
map <c-f> $lf -remote "send $id select '$(fzf)'"
map J :updir; down
map K :updir; up

# File operations
map DD delete
map dD trash
map p paste
map P paste-overwrite
map x cut
map y copy
map <c-r> reload
map mf mkfile
map md mkdir
map ch chmod
map br bulk-rename

# Archive operations
map ex extract
map cz compress

# Copy/paste helpers
map Yp yank-path
map Yn yank-name

# Movement
map gD cd ~/Documents
map gd cd ~/Downloads
map gp cd ~/Pictures
map gc cd ~/.config
map gr cd /
map gh cd ~
map gt cd ~/.local/share/Trash/files

# Wayland specific
map dr dragon

# Clear selections
map u unselect

# Preview toggling
map zp set preview!
map zi set icons!
map zh set hidden!\t' read -r src dst; do
        [ "$src" = "$dst" ] || [ -e "$dst" ] || mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

cmd dragon ${{
    dragon-drop -a -x $fx
}}

cmd yank-path ${{
    printf '%s' "$fx" | wl-copy
    lf -remote "send $id echo Copied path to clipboard"
}}

cmd yank-name ${{
    basename -a -- $fx | head -c-1 | wl-copy
    lf -remote "send $id echo Copied name to clipboard"
}}

cmd paste-overwrite &{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        cp -rf $list .
    elif [ $mode = 'move' ]; then
        mv -f $list .
    fi
    lf -remote 'send clear'
}}

# Key Bindings
map <enter> open
map <c-f> $lf -remote "send $id select '$(fzf)'"
map J :updir; down
map K :updir; up

# File operations
map DD delete
map dD trash
map p paste
map P paste-overwrite
map x cut
map y copy
map <c-r> reload
map mf mkfile
map md mkdir
map ch chmod
map br bulk-rename

# Archive operations
map ex extract
map cz compress

# Copy/paste helpers
map Yp yank-path
map Yn yank-name

# Movement
map gD cd ~/Documents
map gd cd ~/Downloads
map gp cd ~/Pictures
map gc cd ~/.config
map gr cd /
map gh cd ~
map gt cd ~/.local/share/Trash/files

# Wayland specific
map dr dragon

# Clear selections
map u unselect

# Preview toggling
map zp set preview!
map zi set icons!
map zh set hidden!

# Custom commands
cmd open ${{
    case $(file --mime-type -Lb $f) in
        text/*|application/json|inode/x-empty|application/x-subrip) 
            $EDITOR $fx
            ;;
        image/*)
            kitty +kitten icat --clear --transfer-mode=memory --stdin=no --place=${w}x${h}@${x}@${y} $f
            ;;
        video/*|image/gif)
            mpv --quiet $f &
            ;;
        audio/*)
            mpv --no-video $f &
            ;;
        application/pdf)
            zathura $f &
            ;;
        application/zip|application/x-tar|application/x-rar)
            atool -l $f | less
            ;;
        *)
            xdg-open $f &
            ;;
    esac
}}

cmd mkdir ${{
    printf '%s' "Directory Name: "
    read ans
    mkdir -p "$ans"
}}

cmd mkfile ${{
    printf '%s' "File Name: "
    read ans
    touch "$ans"
}}

cmd chmod ${{
    printf '%s' "Mode Bits: "
    read ans
    chmod $ans $fx
}}

cmd trash ${{
    files=$(printf '%s' "$fx" | tr '\n' ';')
    while [ "$files" ]; do
        file=${files%%;*}
        if [ -e "$file" ]; then
            gio trash "$file"
        fi
        if [ "$files" = "$file" ]; then
            files=''
        else
            files="${files#*;}"
        fi
    done
}}

cmd delete ${{
    set -f
    printf '%s\n' "$fx"
    printf "delete?[y/n]"
    read ans
    [ "$ans" = "y" ] && rm -rf $fx
}}

cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
        *) echo "Unsupported format";;
    esac
}}

cmd compress ${{
    set -f
    printf '%s' "Archive name (without extension): "
    read name
    printf '%s' "Format [zip/tar.gz/tar.xz]: "
    read format
    case $format in
        zip) zip -r "${name}.zip" $fx;;
        tar.gz) tar czf "${name}.tar.gz" $fx;;
        tar.xz) tar cJf "${name}.tar.xz" $fx;;
        *) echo "Unsupported format";;
    esac
}}

cmd fzf_jump ${{
    res="$(find . -maxdepth 3 | fzf --reverse --header='Jump to location')"
    if [ -f "$res" ]; then
        cmd="select"
    elif [ -d "$res" ]; then
        cmd="cd"
    fi
    lf -remote "send $id $cmd \"$res\""
}}

cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS=$'\t' read -r src dst; do
        [ "$src" = "$dst" ] || [ -e "$dst" ] || mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

cmd dragon ${{
    dragon-drop -a -x $fx
}}

cmd yank-path ${{
    printf '%s' "$fx" | wl-copy
    lf -remote "send $id echo Copied path to clipboard"
}}

cmd yank-name ${{
    basename -a -- $fx | head -c-1 | wl-copy
    lf -remote "send $id echo Copied name to clipboard"
}}

cmd paste-overwrite &{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        cp -rf $list .
    elif [ $mode = 'move' ]; then
        mv -f $list .
    fi
    lf -remote 'send clear'
}}

# Key Bindings
map <enter> open
map <c-f> $lf -remote "send $id select '$(fzf)'"
map J :updir; down
map K :updir; up

# File operations
map DD delete
map dD trash
map p paste
map P paste-overwrite
map x cut
map y copy
map <c-r> reload
map mf mkfile
map md mkdir
map ch chmod
map br bulk-rename

# Archive operations
map ex extract
map cz compress

# Copy/paste helpers
map Yp yank-path
map Yn yank-name

# Movement
map gD cd ~/Documents
map gd cd ~/Downloads
map gp cd ~/Pictures
map gc cd ~/.config
map gr cd /
map gh cd ~
map gt cd ~/.local/share/Trash/files

# Wayland specific
map dr dragon

# Clear selections
map u unselect

# Preview toggling
map zp set preview!
map zi set icons!
map zh set hidden!
